"""
Code for generating trees using ms and comparing them to the emission matrix of the variable_migration_model2.
"""

#!/usr/bin/env python

import newick.tree, newick
import pylab
import re
import subprocess
from argparse import ArgumentParser
import bisect

parser = ArgumentParser(usage="generate from ms-variable-migration-model and construct emission matrices", version="%(prog)s 1.0")

parser.add_argument("-p","--prefix",
                    type=str,
                    default="/home/svendvn/",
                    help="All files generated by the script have programmer-defined names but they should be saved somewhere. That directory is supplied here")
parser.add_argument("-y","--python_prefix",
                    type=str,
                    default="",
                    help="If the python scripts is not placed in the same folder as here prefix it should be pointed out here with their directory")

parser.add_argument('-r',"--reps", type=int, default=1, help="number of times 1000000 positions should be simulated.")

options=parser.parse_args()
fileprefix=options.prefix
if options.python_prefix:
    pythonprefix=options.python_prefix
else:
    pythonprefix=options.prefix


_MS_PATH = 'ms'
_SEQGEN_PATH= 'seq-gen'
coal_rho = 800.0
seg_length = 1000000.0
s2=seg_length/10.0
Ne=20000
gen=25
mu=1e-9
rho_per_gen=1e-8
coal_mig_rate=0.5
sym_coal_mig_rate=coal_mig_rate*2
old_val=sym_coal_mig_rate
theta_years=4*Ne*gen
#coal_rho=rho_per_gen*4*Ne*gen
theta_subs=mu*theta_years
rho_subs=rho_per_gen/(mu*gen)
new_val=sym_coal_mig_rate/2.0
new_val2=sym_coal_mig_rate/5.0
substime_first_change=0.0005
substime_second_change=0.0010
substime_third_change=0.0030
time_first_change=substime_first_change/theta_subs
time_second_change=substime_second_change/theta_subs
time_third_change=substime_third_change/theta_subs
reps=options.reps


#ms 4 1 -T -r ${coal_rho} ${seg_length} -I 2 2 2 -em ${mstime_for_change} 1 2 $changed_migration -em ${mstime_for_change} 2 1 $changed_migration2 -ej $mstime_for_change_back 1 2
def simulate_forest(forest_file,sequence_file,align_dir_file):
    seqgen_args= ['-q','-mHKY','-l', str(seg_length),'-s',str(theta_subs),'-p',str(s2),forest_file]
#     ms_args = ['4', '1', '-T', '-r', str(1000.0), str(seg_length), '-I', '2', '2', '2', '1.0','-em',str(time_first_change),'1','2',str(new_val), 
#                '-em', str(time_second_change),'1','2',str(old_val),'-em',str(time_second_change), '2','1', str(new_val2), '-em', str(time_third_change), '2','1', str(old_val)]
    ms_args = ['4', '1', '-T', '-r', str(1000.0), str(seg_length), '-I', '2', '2', '2','-em',str(time_first_change),'1','2',str(new_val),
               '-em',str(time_first_change),'2','1',str(new_val2),'-ej', str(time_second_change),'1','2']
        #python /home/svendvn/workspace/IMCoalHMM/scripts/prepare-alignments.py --names=1,2 ${seqfile} phylip ${ziphmmfile11} --where_path_ends 3

    with open(forest_file, 'w') as f:
        p = subprocess.Popen([_MS_PATH] + ms_args, stdout=subprocess.PIPE)
        line_number = 0
        for line in p.stdout.readlines():
            line_number += 1
            if line_number >= 4 and '//' not in line:
                f.write(line)
    print "."

    with open(sequence_file, 'w') as f:
        p = subprocess.Popen([_SEQGEN_PATH] + seqgen_args, stdout=subprocess.PIPE)
        print ","
        line_number = 0
        for line in p.stdout.readlines():
            line_number += 1
            if line_number >= 1:
                f.write(line)
    print ","
    subprocess.call(['python',pythonprefix+'prepare-alignments.py', '--names=1,2', sequence_file,'phylip', align_dir_file[0], '--where_path_ends', str(3)])
    subprocess.call(['python',pythonprefix+'prepare-alignments.py', '--names=3,4', sequence_file,'phylip', align_dir_file[1], '--where_path_ends', str(3)])
    subprocess.call(['python',pythonprefix+'prepare-alignments.py', '--names=1,3', sequence_file,'phylip', align_dir_file[2], '--where_path_ends', str(3)])

class PairTMRCA(newick.tree.TreeVisitor):
    '''class for finding the TMRCA for all the pairs of leaves in a tree'''
        
    def pre_visit_edge(self, src, bootstrap, length, dst):
        subtree_leaves = set(map(int,dst.get_leaves_identifiers()))
        rest_leaves = self.all_leaves.difference(subtree_leaves)
        # for all leaves that have not been visited already, 
        # such that i is in subtree_leaves and j is in rest_leaves
        # update the corresponding tmrca with length
        for i in subtree_leaves:
            for j in rest_leaves:
                    min_leaf = min(i, j)
                    max_leaf = max(i, j)
                    self.tmrca[(min_leaf, max_leaf)] += length/2

    def get_TMRCA(self, string_tree):
        tree = newick.tree.parse_tree(string_tree)
        self.all_leaves = set(map(int,tree.get_leaves_identifiers()))
        no_leaves = len(self.all_leaves)
        self.tmrca = {}
        # initialize the tmrca to 0
        for i in range(no_leaves-1):
            for j in range(i+1,no_leaves):
                self.tmrca[(i+1,j+1)] = 0
        tree.dfs_traverse(self)
        return self.tmrca

def process_tree(line):
    if line[0] != '[':
        return None, None
    s = line.strip().split("[")[1].split("]")
    return int(s[0]), s[1]

def count_tmrca(filename, subs):
    visitor = PairTMRCA()
    f = open(filename)
    one_two = []
    three_four = []
    one_three = []
    for line in f:
        count, tree = process_tree(line)
        tmrca = visitor.get_TMRCA(tree)
        one_two.extend([tmrca[(1,2)]*subs] * count)
        three_four.extend([tmrca[(3,4)]*subs] * count)
        one_three.extend([tmrca[(1,3)]*subs] * count)
    f.close()

    return one_two, three_four, one_three

forestfile=fileprefix+"forest.nwk"
alignphyle=fileprefix+"alignemnt.phylip"
align_dirs=[fileprefix+"aligndd1",fileprefix+"aligndd2",fileprefix+"aligndd3"]

import imp
breaks = imp.load_source('break_points2', pythonprefix+'break_points2.py')
#bins=[0.0, 8.3381608939051073e-05, 0.0001743533871447778, 0.00027443684570176033, 0.00038566248081198473, 0.0005108256237659907, 0.00065392646740666392, 0.00082098055206983008, 0.0010216512475319816, 0.0012729656758128879, 0.0015213904$

bins=breaks.gamma_break_points(15,beta1=0.001, alpha=2,beta2=float(1)/750.0,tenthsInTheEnd=3,
                               fixed_time_points=[(5,substime_first_change),(10,substime_second_change)])
bins.append(1)

import time
start_time = time.time()
ll=[0]*((len(bins)-1)*2)
rr=[0]*((len(bins)-1)*2)
cc=[0]*((len(bins)-1)*2)

def countEmissions(vector,bins,emiss):
    ans=[0]*((len(bins)-1)*2)
    vector2=[bisect.bisect(bins,x)-1 for x in vector]
    for t,m in zip(vector2,emiss):
            ans[t*2+m]+=1
    return ans


for i in xrange(reps):
    for r in align_dirs:
        subprocess.call(['rm','-R',r])
    simulate_forest(forestfile, alignphyle, align_dirs)
    print "simulated trees "+str(i)
    l,r,c = count_tmrca(fileprefix+"forest.nwk", theta_subs)
    print "uncovered tree lengths " + str(i)
    f=open(align_dirs[0]+"/original_sequence", 'r')
    emiss1=map(int,f.readline().split(" "))
    f=open(align_dirs[1]+"/original_sequence", 'r')
    emiss2=map(int,f.readline().split(" "))
    f=open(align_dirs[2]+"/original_sequence", 'r')
    emiss3=map(int,f.readline().split(" "))
    

    t=(countEmissions(l,bins,emiss1),)
    ll=[old+new for old,new in zip(ll,t[0])]
    t=(countEmissions(r,bins,emiss2),)
    rr=[old+new for old,new in zip(rr,t[0])]
    t=(countEmissions(c,bins,emiss3),)
    cc=[old+new for old,new in zip(cc,t[0])]
    print "counted up "+str(i)+". elapsed=" + str(time.time()-start_time)
    print ll
    print rr
    print cc
    
def constructEmissionProbability(emissvector,filename):
    with open(filename,'w') as f:
        for i in xrange(len(emissvector)/2):
            a=emissvector[i*2]
            b=emissvector[i*2+1]
            f.write(str(float(a)/float(a+b+1.0))+" "+str(float(b)/float((a+b+1)))+"\n")
            
            
constructEmissionProbability(ll, fileprefix+"ll_empirical_ms.txt")
constructEmissionProbability(rr, fileprefix+"rr_empirical_ms.txt")
constructEmissionProbability(cc, fileprefix+"cc_empirical_ms.txt")

def time_modifier():
    return [(5,substime_first_change),(10,substime_second_change)]

def printPyZipHMM(Matrix):
    finalString=""
    for i in range(Matrix.getHeight()):
        for j in range(Matrix.getWidth()):
            finalString=finalString+" "+str(Matrix[i,j])
        finalString=finalString+"\n"
    return finalString

#this is for testing the already verified variableCoalAndMigrationModel.py
# varb = imp.load_source('variable_migration_model2', pythonprefix+'variable_migration_model2.py')
# def constructTrueEmissionProbability(params, model,filename):
#     cd=varb.VariableCoalAndMigrationRateModel(model, intervals=[5,5,5,5], breaktimes=1.0,breaktail=3, time_modifier=time_modifier)
#     _,_,e,_=cd.build_hidden_markov_model(params)
#     estr=printPyZipHMM(e)
#     with open(filename,'w') as f:
#         f.write(estr)
# parm=[1000,1000,1000,1000,  1000,1000,1000,1000,    500,250,500,500,    500,500,100,500,    0.4]
# constructTrueEmissionProbability(parm,varb.VariableCoalAndMigrationRateModel.INITIAL_11, fileprefix+"ll_theoretical_coalHMM.txt")
# constructTrueEmissionProbability(parm,varb.VariableCoalAndMigrationRateModel.INITIAL_22, fileprefix+"rr_theoretical_coalHMM.txt")
# constructTrueEmissionProbability(parm,varb.VariableCoalAndMigrationRateModel.INITIAL_12, fileprefix+"cc_theoretical_coalHMM.txt")


varb = imp.load_source('variable_migration_model_with_ancestral', pythonprefix+'variable_migration_model_with_ancestral.py')
def constructTrueEmissionProbability2(params, model,filename):
    cd=varb.VariableCoalAndMigrationRateAndAncestralModel(model, intervals=[5,5,5], breaktimes=1.0,breaktail=3,time_modifier=time_modifier)
    _,_,e,_=cd.build_hidden_markov_model(params)
    estr=printPyZipHMM(e)
    with open(filename,'w') as f:
        f.write(estr)
parm=[1000,1000,1000,  1000,1000,1000,    0,250,500,    0,100,500,    0.4]
constructTrueEmissionProbability2(parm,varb.VariableCoalAndMigrationRateAndAncestralModel.INITIAL_11, fileprefix+"ll_theoretical_coalHMM.txt")
constructTrueEmissionProbability2(parm,varb.VariableCoalAndMigrationRateAndAncestralModel.INITIAL_22, fileprefix+"rr_theoretical_coalHMM.txt")
constructTrueEmissionProbability2(parm,varb.VariableCoalAndMigrationRateAndAncestralModel.INITIAL_12, fileprefix+"cc_theoretical_coalHMM.txt")


