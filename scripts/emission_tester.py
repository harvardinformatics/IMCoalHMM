"""
Code for generating trees using ms and comparing them to the emission matrix of the variable_migration_model2.
"""

#!/usr/bin/env python

import newick.tree, newick
import pylab
import re
import subprocess
from argparse import ArgumentParser
import bisect
from numpy import array
from numpy import sum as npsum
from math import ceil,isnan

parser = ArgumentParser(usage="generate from ms-variable-migration-model and construct emission matrices", version="%(prog)s 1.0")

parser.add_argument("-p","--prefix",
                    type=str,
                    default="/home/svendvn/",
                    help="All files generated by the script have programmer-defined names but they should be saved somewhere. That directory is supplied here")
parser.add_argument("-y","--python_prefix",
                    type=str,
                    default="",
                    help="If the python scripts is not placed in the same folder as here prefix it should be pointed out here with their directory")

parser.add_argument('-r',"--reps", type=int, default=1, help="number of times 1000000 positions should be simulated.")
parser.add_argument('-m',"--m", type=int, default=1, help="scheme to use")
parser.add_argument('--Model',type=str, default="A", help="""If m==3, this is the type of ABET-model that is analysed. Options=["A","B","E","T"]""")

options=parser.parse_args()
fileprefix=options.prefix
if options.python_prefix:
    pythonprefix=options.python_prefix
else:
    pythonprefix=options.prefix


_MS_PATH = 'ms'
_SEQGEN_PATH= 'seq-gen'
coal_rho = 800.0
seg_length = 1000000.0
s2=seg_length/10.0
Ne=20000
gen=25
mu=1e-9
rho_per_gen=1e-8
coal_mig_rate=0.5
sym_coal_mig_rate=coal_mig_rate*2
old_val=sym_coal_mig_rate
theta_years=4*Ne*gen
#coal_rho=rho_per_gen*4*Ne*gen
theta_subs=mu*theta_years
rho_subs=rho_per_gen/(mu*gen)
new_val=sym_coal_mig_rate/2.0
new_val2=sym_coal_mig_rate/5.0
substime_first_change=0.0005
substime_second_change=0.0010
substime_third_change=0.0030
time_first_change=substime_first_change/theta_subs
time_second_change=substime_second_change/theta_subs
time_third_change=substime_third_change/theta_subs
reps=options.reps

changed_migration=sym_coal_mig_rate
changed_migration2=sym_coal_mig_rate*2

p11_1=0.9
p11_2=0.9
p11_3=1.0
p22_1=0.8
p22_2=0.8
p22_3=0.0


#ms 4 1 -T -r ${coal_rho} ${seg_length} -I 2 2 2 -em ${mstime_for_change} 1 2 $changed_migration -em ${mstime_for_change} 2 1 $changed_migration2 -ej $mstime_for_change_back 1 2
def simulate_forest(forest_file,sequence_file,align_dir_file):
    seqgen_args= ['-q','-mHKY','-l', str(seg_length),'-s',str(theta_subs),'-p',str(s2),forest_file]
#     ms_args = ['4', '1', '-T', '-r', str(1000.0), str(seg_length), '-I', '2', '2', '2', '1.0','-em',str(time_first_change),'1','2',str(new_val), 
#                '-em', str(time_second_change),'1','2',str(old_val),'-em',str(time_second_change), '2','1', str(new_val2), '-em', str(time_third_change), '2','1', str(old_val)]
    ms_args = ['4', '1', '-T', '-r', str(1000.0), str(seg_length), '-I', '2', '2', '2','-em',str(time_first_change),'1','2',str(new_val),
               '-em',str(time_first_change),'2','1',str(new_val2),'-ej', str(time_second_change),'1','2']
        #python /home/svendvn/workspace/IMCoalHMM/scripts/prepare-alignments.py --names=1,2 ${seqfile} phylip ${ziphmmfile11} --where_path_ends 3

    with open(forest_file, 'w') as f:
        p = subprocess.Popen([_MS_PATH] + ms_args, stdout=subprocess.PIPE)
        line_number = 0
        for line in p.stdout.readlines():
            line_number += 1
            if line_number >= 4 and '//' not in line:
                f.write(line)
    print "."

    with open(sequence_file, 'w') as f:
        p = subprocess.Popen([_SEQGEN_PATH] + seqgen_args, stdout=subprocess.PIPE)
        print ","
        line_number = 0
        for line in p.stdout.readlines():
            line_number += 1
            if line_number >= 1:
                f.write(line)
    print ","
    subprocess.call(['python',pythonprefix+'prepare-alignments.py', '--names=1,2', sequence_file,'phylip', align_dir_file[0], '--where_path_ends', str(3)])
    subprocess.call(['python',pythonprefix+'prepare-alignments.py', '--names=3,4', sequence_file,'phylip', align_dir_file[1], '--where_path_ends', str(3)])
    subprocess.call(['python',pythonprefix+'prepare-alignments.py', '--names=1,3', sequence_file,'phylip', align_dir_file[2], '--where_path_ends', str(3)])

def simulate_forest2(forest_file,sequence_file,align_dir_file): 
    '''
    iim with and without outgroup
    '''
    
    seqgen_args= ['-q','-mHKY','-l', str(seg_length),'-s',str(theta_subs),'-p',str(s2),forest_file]
#     ms_args = ['4', '1', '-T', '-r', str(1000.0), str(seg_length), '-I', '2', '2', '2', '1.0','-em',str(time_first_change),'1','2',str(new_val), 
#                '-em', str(time_second_change),'1','2',str(old_val),'-em',str(time_second_change), '2','1', str(new_val2), '-em', str(time_third_change), '2','1', str(old_val)]
    ms_args = ['4', '1', '-T', '-r', str(1000.0), str(seg_length), '-I', '2', '2', '2','0.0', 
               '-es',str(time_first_change),'1', str(p11_1), '-es',str(time_first_change),'2', str(p22_1),
               '-ej',str(time_first_change),'3', '2', '-ej',str(time_first_change),'4', '1',
               '-es',str(time_second_change),'1', str(p11_2), '-es',str(time_second_change),'2', str(p22_2),
               '-ej',str(time_second_change),'5', '2', '-ej',str(time_second_change),'6', '1',
               '-ej',str(time_third_change),'1','2']
    #em {mstime_for_change} 2 1 {changed_migration} -em {mstime_for_change} 1 2 {changed_migration} -ej {mstime_for_change2} 2 1 -ej {mstime_for_outgroup} 1 3
        #python /home/svendvn/workspace/IMCoalHMM/scripts/prepare-alignments.py --names=1,2 ${seqfile} phylip ${ziphmmfile11} --where_path_ends 3

    with open(forest_file, 'w') as f:
        p = subprocess.Popen([_MS_PATH] + ms_args, stdout=subprocess.PIPE)
        line_number = 0
        for line in p.stdout.readlines():
            line_number += 1
            if line_number >= 4 and '//' not in line:
                f.write(line)
    print "."

    with open(sequence_file, 'w') as f:
        p = subprocess.Popen([_SEQGEN_PATH] + seqgen_args, stdout=subprocess.PIPE)
        print ","
        line_number = 0
        for line in p.stdout.readlines():
            line_number += 1
            if line_number >= 1:
                f.write(line)
    print ","
    subprocess.call(['python',pythonprefix+'prepare-alignments.py', '--names=1,2', sequence_file,'phylip', align_dir_file[0], '--where_path_ends', str(3)])
    subprocess.call(['python',pythonprefix+'prepare-alignments.py', '--names=3,4', sequence_file,'phylip', align_dir_file[1], '--where_path_ends', str(3)])
    subprocess.call(['python',pythonprefix+'prepare-alignments.py', '--names=1,3', sequence_file,'phylip', align_dir_file[2], '--where_path_ends', str(3)])

def simulate_forest3(forest_file,sequence_file,align_dir_file): 
    '''
    iim with and without outgroup
    '''
    
    seqgen_args= ['-q','-mHKY','-l', str(seg_length),'-s',str(theta_subs),'-p',str(s2),forest_file]
#     ms_args = ['4', '1', '-T', '-r', str(1000.0), str(seg_length), '-I', '2', '2', '2', '1.0','-em',str(time_first_change),'1','2',str(new_val), 
#                '-em', str(time_second_change),'1','2',str(old_val),'-em',str(time_second_change), '2','1', str(new_val2), '-em', str(time_third_change), '2','1', str(old_val)]
    ms_args_A = ['4', '1', '-T', '-r', str(coal_rho), str(seg_length), '-I', '2', '2', '2','0.0', 
               '-em',str(time_first_change),'1', '2', str(changed_migration), 
               '-ej',str(time_second_change),'2', '1']
    ms_args_B = ['4', '1', '-T', '-r', str(coal_rho), str(seg_length), '-I', '2', '2', '2','0.0', 
               '-em',str(time_first_change),'2', '1', str(changed_migration), 
               '-ej',str(time_second_change),'1', '2']
    ms_args_E = ['4', '1', '-T', '-r', str(coal_rho), str(seg_length), '-I', '2', '2', '2','0.0', 
               '-em',str(time_first_change),'2', '1', str(changed_migration), 
               '-em',str(time_first_change),'1', '2', str(changed_migration), 
               '-ej',str(time_second_change),'1', '2']
    ms_args_T = ['4', '1', '-T', '-r', str(coal_rho), str(seg_length), '-I', '2', '2', '2','0.0', 
               '-em',str(time_first_change),'2', '1', str(changed_migration), 
               '-em',str(time_first_change),'1', '2', str(changed_migration2), 
               '-ej',str(time_second_change),'1', '2']
    #em {mstime_for_change} 2 1 {changed_migration} -em {mstime_for_change} 1 2 {changed_migration} -ej {mstime_for_change2} 2 1 -ej {mstime_for_outgroup} 1 3
        #python /home/svendvn/workspace/IMCoalHMM/scripts/prepare-alignments.py --names=1,2 ${seqfile} phylip ${ziphmmfile11} --where_path_ends 3
    
    ms_args={'A':ms_args_A, 'B':ms_args_B, "E":ms_args_E, "T":ms_args_T}
    
    with open(forest_file, 'w') as f:
        
        p = subprocess.Popen([_MS_PATH] + ms_args[options.Model], stdout=subprocess.PIPE)
        line_number = 0
        for line in p.stdout.readlines():
            line_number += 1
            if line_number >= 4 and '//' not in line:
                f.write(line)
    print "."

    with open(sequence_file, 'w') as f:
        p = subprocess.Popen([_SEQGEN_PATH] + seqgen_args, stdout=subprocess.PIPE)
        print ","
        line_number = 0
        for line in p.stdout.readlines():
            line_number += 1
            if line_number >= 1:
                f.write(line)
    print ","
    subprocess.call(['python',pythonprefix+'prepare-alignments.py', '--names=1,2', sequence_file,'phylip', align_dir_file[0], '--where_path_ends', str(3)])
    subprocess.call(['python',pythonprefix+'prepare-alignments.py', '--names=3,4', sequence_file,'phylip', align_dir_file[1], '--where_path_ends', str(3)])
    subprocess.call(['python',pythonprefix+'prepare-alignments.py', '--names=1,3', sequence_file,'phylip', align_dir_file[2], '--where_path_ends', str(3)])

def simulate_forest4(forest_file,sequence_file,align_dir_file): 
    '''
    iim with and without outgroup
    '''
    
    seqgen_args= ['-q','-mHKY','-l', str(seg_length),'-s',str(theta_subs),'-p',str(s2),forest_file]
#     ms_args = ['4', '1', '-T', '-r', str(1000.0), str(seg_length), '-I', '2', '2', '2', '1.0','-em',str(time_first_change),'1','2',str(new_val), 
#                '-em', str(time_second_change),'1','2',str(old_val),'-em',str(time_second_change), '2','1', str(new_val2), '-em', str(time_third_change), '2','1', str(old_val)]
    ms_args = ['4', '1', '-T', '-r', str(coal_rho), str(seg_length), '-I', '2', '2', '2',str(sym_coal_mig_rate), 
               '-em',str(time_first_change),'1', '2', str(new_val), 
               '-em',str(time_second_change),'1', '2', str(sym_coal_mig_rate), 
               '-em',str(time_second_change),'2', '1', str(new_val2), 
               '-em',str(time_third_change),'2', '1', str(sym_coal_mig_rate)]
    #em {mstime_for_change} 2 1 {changed_migration} -em {mstime_for_change} 1 2 {changed_migration} -ej {mstime_for_change2} 2 1 -ej {mstime_for_outgroup} 1 3
        #python /home/svendvn/workspace/IMCoalHMM/scripts/prepare-alignments.py --names=1,2 ${seqfile} phylip ${ziphmmfile11} --where_path_ends 3

    with open(forest_file, 'w') as f:
        p = subprocess.Popen([_MS_PATH] + ms_args, stdout=subprocess.PIPE)
        line_number = 0
        for line in p.stdout.readlines():
            line_number += 1
            if line_number >= 4 and '//' not in line:
                f.write(line)
    print "."

    with open(sequence_file, 'w') as f:
        p = subprocess.Popen([_SEQGEN_PATH] + seqgen_args, stdout=subprocess.PIPE)
        print ","
        line_number = 0
        for line in p.stdout.readlines():
            line_number += 1
            if line_number >= 1:
                f.write(line)
    print ","
    subprocess.call(['python',pythonprefix+'prepare-alignments.py', '--names=1,2', sequence_file,'phylip', align_dir_file[0], '--where_path_ends', str(3)])
    subprocess.call(['python',pythonprefix+'prepare-alignments.py', '--names=3,4', sequence_file,'phylip', align_dir_file[1], '--where_path_ends', str(3)])
    subprocess.call(['python',pythonprefix+'prepare-alignments.py', '--names=1,3', sequence_file,'phylip', align_dir_file[2], '--where_path_ends', str(3)])


class PairTMRCA(newick.tree.TreeVisitor):
    '''class for finding the TMRCA for all the pairs of leaves in a tree'''
        
    def pre_visit_edge(self, src, bootstrap, length, dst):
        subtree_leaves = set(map(int,dst.get_leaves_identifiers()))
        rest_leaves = self.all_leaves.difference(subtree_leaves)
        # for all leaves that have not been visited already, 
        # such that i is in subtree_leaves and j is in rest_leaves
        # update the corresponding tmrca with length
        for i in subtree_leaves:
            for j in rest_leaves:
                    min_leaf = min(i, j)
                    max_leaf = max(i, j)
                    self.tmrca[(min_leaf, max_leaf)] += length/2

    def get_TMRCA(self, string_tree):
        tree = newick.tree.parse_tree(string_tree)
        self.all_leaves = set(map(int,tree.get_leaves_identifiers()))
        no_leaves = len(self.all_leaves)
        self.tmrca = {}
        # initialize the tmrca to 0
        for i in range(no_leaves-1):
            for j in range(i+1,no_leaves):
                self.tmrca[(i+1,j+1)] = 0
        tree.dfs_traverse(self)
        return self.tmrca

def process_tree(line):
    if line[0] != '[':
        return None, None
    s = line.strip().split("[")[1].split("]")
    return int(s[0]), s[1]

def count_tmrca(filename, subs):
    visitor = PairTMRCA()
    f = open(filename)
    one_two = []
    three_four = []
    one_three = []
    for line in f:
        count, tree = process_tree(line)
        tmrca = visitor.get_TMRCA(tree)
        one_two.extend([tmrca[(1,2)]*subs] * count)
        three_four.extend([tmrca[(3,4)]*subs] * count)
        one_three.extend([tmrca[(1,3)]*subs] * count)
    f.close()

    return one_two, three_four, one_three

forestfile=fileprefix+"forest.nwk"
alignphyle=fileprefix+"alignemnt.phylip"
align_dirs=[fileprefix+"aligndd1",fileprefix+"aligndd2",fileprefix+"aligndd3"]

import imp
breaks = imp.load_source('break_points2', pythonprefix+'break_points2.py')
#bins=[0.0, 8.3381608939051073e-05, 0.0001743533871447778, 0.00027443684570176033, 0.00038566248081198473, 0.0005108256237659907, 0.00065392646740666392, 0.00082098055206983008, 0.0010216512475319816, 0.0012729656758128879, 0.0015213904$

if options.m==2:
    bins=breaks.gamma_break_points(20,beta1=0.001, alpha=2,beta2=float(1)/750.0,tenthsInTheEnd=3,
                                   fixed_time_points=[(5,substime_first_change),(10,substime_second_change),(15, substime_third_change)])
elif options.m==4:
    bins=breaks.gamma_break_points(20,beta1=0.001, alpha=2,beta2=float(1)/750.0,tenthsInTheEnd=3,
                                   fixed_time_points=[(5,substime_first_change),(10,substime_second_change),(15, substime_third_change)])
else:
    bins=breaks.gamma_break_points(15,beta1=0.001, alpha=2,beta2=float(1)/750.0,tenthsInTheEnd=3,
                                   fixed_time_points=[(5,substime_first_change),(10,substime_second_change)])
print bins

import time
start_time = time.time()
ll=[0]*((len(bins))*2)
rr=[0]*((len(bins))*2)
cc=[0]*((len(bins))*2)

def countEmissions(vector,bins,emiss):
    ans=[0]*((len(bins))*2)
    empirical_transitions=[]
    for i in range(len(bins)):
        empirical_transitions.append([0]*(len(bins)))
    vector2=[bisect.bisect(bins,x)-1 for x in vector]
    previousCategory=-1
    for t,m in zip(vector2,emiss):
            ans[t*2+m]+=1
            if previousCategory!=-1:
                empirical_transitions[previousCategory][t]+=1
            previousCategory=t
    return ans, empirical_transitions

ll_trans=None
rr_trans=None
cc_trans=None
for i in xrange(reps):
    for r in align_dirs:
        subprocess.call(['rm','-Rf',r])
    if options.m==1:
        simulate_forest(forestfile, alignphyle, align_dirs)
    elif options.m==2:
        simulate_forest2(forestfile, alignphyle, align_dirs)
    elif options.m==3:
        simulate_forest3(forestfile, alignphyle, align_dirs)
    elif options.m==4:
        simulate_forest4(forestfile, alignphyle, align_dirs)
    print "simulated trees "+str(i)
    l,r,c = count_tmrca(fileprefix+"forest.nwk", theta_subs)
    print "uncovered tree lengths " + str(i)
    f=open(align_dirs[0]+"/original_sequence", 'r')
    emiss1=map(int,f.readline().split(" "))
    f=open(align_dirs[1]+"/original_sequence", 'r')
    emiss2=map(int,f.readline().split(" "))
    f=open(align_dirs[2]+"/original_sequence", 'r')
    emiss3=map(int,f.readline().split(" "))
    
    
    ls,transl=countEmissions(l,bins,emiss1)
    ll=[old+new for old,new in zip(ll,ls)]
    rs,transr=countEmissions(r,bins,emiss2)
    rr=[old+new for old,new in zip(rr,rs)]
    cs,transc=countEmissions(c,bins,emiss3)
    cc=[old+new for old,new in zip(cc,cs)]
    
    if ll_trans is None:
        ll_trans=array(transl)
    else:
        ll_trans+=array(transl)
    if rr_trans is None:
        rr_trans=array(transr)
    else:
        rr_trans+=array(transr)
    if cc_trans is None:
        cc_trans=array(transc)
    else:
        cc_trans+=array(transc)
    
    print "counted up "+str(i)+". elapsed=" + str(time.time()-start_time)
    print ll
    print rr
    print cc
    


def time_modifier():
    return [(5,substime_first_change),(10,substime_second_change),(15, substime_third_change)]
def time_modifier2():
    return [(5,substime_first_change),(10,substime_second_change)]

def printPyZipHMM(Matrix):
    finalString=""
    for i in range(Matrix.getHeight()):
        for j in range(Matrix.getWidth()):
            finalString=finalString+" "+str(Matrix[i,j])
        finalString=finalString+"\n"
    return finalString

#this is for testing the already verified variableCoalAndMigrationModel.py
# varb = imp.load_source('variable_migration_model2', pythonprefix+'variable_migration_model2.py')
# def constructTrueEmissionProbability(params, model,filename):
#     cd=varb.VariableCoalAndMigrationRateModel(model, intervals=[5,5,5,5], breaktimes=1.0,breaktail=3, time_modifier=time_modifier)
#     _,_,e,_=cd.build_hidden_markov_model(params)
#     estr=printPyZipHMM(e)
#     with open(filename,'w') as f:
#         f.write(estr)
# parm=[1000,1000,1000,1000,  1000,1000,1000,1000,    500,250,500,500,    500,500,100,500,    0.4]
# constructTrueEmissionProbability(parm,varb.VariableCoalAndMigrationRateModel.INITIAL_11, fileprefix+"ll_theoretical_coalHMM.txt")
# constructTrueEmissionProbability(parm,varb.VariableCoalAndMigrationRateModel.INITIAL_22, fileprefix+"rr_theoretical_coalHMM.txt")
# constructTrueEmissionProbability(parm,varb.VariableCoalAndMigrationRateModel.INITIAL_12, fileprefix+"cc_theoretical_coalHMM.txt")

from variable_migration_model_with_ancestral import VariableCoalAndMigrationRateAndAncestralModel
from variable_migration_model2 import VariableCoalAndMigrationRateModel
from pulse_model2 import PulseModel
def constructTrueEmissionProbability2(params, model,filename):
    if options.m==1:
        cd=VariableCoalAndMigrationRateAndAncestralModel(model, intervals=[5,5,5], breaktimes=1.0,breaktail=3,time_modifier=time_modifier)
    elif options.m==2:
        cd=PulseModel(model, no_intervals=20, index_of_pulses=array([5,10,15]), breaktimes=1.0, breaktail=3, time_modifier=time_modifier)
    elif options.m==3:
        cd=VariableCoalAndMigrationRateAndAncestralModel(model, intervals=[5,5,5], breaktimes=1.0, breaktail=3, time_modifier=time_modifier2)
    elif options.m==4:
        cd=VariableCoalAndMigrationRateModel(model, intervals=[5,5,5,5], breaktimes=1.0,breaktail=3,time_modifier=time_modifier)
    i,t,e,_=cd.build_hidden_markov_model(params)
    estr=printPyZipHMM(e)
    with open(filename,'w') as f:
        f.write(estr)
    return i,t,e

if options.m==1:
    parm=[1000,1000,1000,  1000,1000,1000,    0,500,0,0,    0,100,0,    0.4]
    i11,t11,e11=constructTrueEmissionProbability2(parm,VariableCoalAndMigrationRateAndAncestralModel.INITIAL_11, fileprefix+"ll_theoretical_coalHMM.txt")
    i22,t22,e22=constructTrueEmissionProbability2(parm,VariableCoalAndMigrationRateAndAncestralModel.INITIAL_22, fileprefix+"rr_theoretical_coalHMM.txt")
    i12,t12,e12=constructTrueEmissionProbability2(parm,VariableCoalAndMigrationRateAndAncestralModel.INITIAL_12, fileprefix+"cc_theoretical_coalHMM.txt")
elif options.m==2:
    parm=array([1000,1000,1000,1000,  1000,1000,1000,1000,    0.1,0.1,1.0,    0.2,0.2,0.0,    0.4])
    i11,t11,e11=constructTrueEmissionProbability2(parm,PulseModel.INITIAL_11, fileprefix+"ll_theoretical_coalHMM.txt")
    i22,t22,e22=constructTrueEmissionProbability2(parm,PulseModel.INITIAL_22, fileprefix+"rr_theoretical_coalHMM.txt")
    i12,t12,e12=constructTrueEmissionProbability2(parm,PulseModel.INITIAL_12, fileprefix+"cc_theoretical_coalHMM.txt")
elif options.m==3:
    parm_A=[1000,1000,1000,  1000,1000,1000,    0,500,0,    0,0,0,        0.4]
    parm_B=[1000,1000,1000,  1000,1000,1000,    0,0,0,      0,500,0,      0.4]
    parm_E=[1000,1000,1000,  1000,1000,1000,    0,500,0,    0,500,0,      0.4]
    parm_T=[1000,1000,1000,  1000,1000,1000,    0,1000,0,    0,500,0,     0.4]
    parm={"A":parm_A, "B":parm_B, "E":parm_E, "T":parm_T}
    i11,t11,e11=constructTrueEmissionProbability2(parm[options.Model],VariableCoalAndMigrationRateAndAncestralModel.INITIAL_11, fileprefix+"ll_theoretical_coalHMM.txt")
    i22,t22,e22=constructTrueEmissionProbability2(parm[options.Model],VariableCoalAndMigrationRateAndAncestralModel.INITIAL_22, fileprefix+"rr_theoretical_coalHMM.txt")
    i12,t12,e12=constructTrueEmissionProbability2(parm[options.Model],VariableCoalAndMigrationRateAndAncestralModel.INITIAL_12, fileprefix+"cc_theoretical_coalHMM.txt")
elif options.m==4:
    parm=array([1000,1000,1000,1000,  1000,1000,1000,1000,    500,250,500,500,   500,500,100,500,    0.4])
    i11,t11,e11=constructTrueEmissionProbability2(parm,VariableCoalAndMigrationRateModel.INITIAL_11, fileprefix+"ll_theoretical_coalHMM.txt")
    i22,t22,e22=constructTrueEmissionProbability2(parm,VariableCoalAndMigrationRateModel.INITIAL_22, fileprefix+"rr_theoretical_coalHMM.txt")
    i12,t12,e12=constructTrueEmissionProbability2(parm,VariableCoalAndMigrationRateModel.INITIAL_12, fileprefix+"cc_theoretical_coalHMM.txt")

from scipy.stats import norm
from math import sqrt
def binom_test(x,n,p):
    if p==0 or n==0:
        return float('Inf')
    if x>n*p:
        return 2*(1-norm.cdf((x-n*p)/sqrt(n*p*(1-p))))
    else:
        return 2*norm.cdf((x-n*p)/sqrt(n*p*(1-p)))
def constructEmissionProbability(emissvector,filename, pred_val=[]):
    e=[]
    test_vector=[]
    with open(filename,'w') as f:
        for i in xrange(len(emissvector)/2):
            a=emissvector[i*2]
            b=emissvector[i*2+1]
            e.append(float(b)/float((a+b+1)))
            if pred_val:
                test_vector.append(  binom_test(b, a+b,p=pred_val[i])  )
            f.write(str(float(a)/float(a+b+1.0))+" "+str(float(b)/float((a+b+1)))+"\n")
    return e, test_vector
            
pred_val11=[e11[i,1] for i in range(len(bins))]           
pred_val12=[e12[i,1] for i in range(len(bins))]            
pred_val22=[e22[i,1] for i in range(len(bins))]   
          
emp11,pval_e_11=constructEmissionProbability(ll, fileprefix+"ll_empirical_ms.txt",pred_val=pred_val11)
emp22,pval_e_12=constructEmissionProbability(rr, fileprefix+"rr_empirical_ms.txt",pred_val=pred_val12)
emp12,pval_e_22=constructEmissionProbability(cc, fileprefix+"cc_empirical_ms.txt",pred_val=pred_val22)

emp_transition_11=ll_trans/float(npsum(ll_trans))
emp_transition_12=cc_trans/float(npsum(cc_trans))
emp_transition_22=rr_trans/float(npsum(rr_trans))
cc_sums=npsum(cc_trans,axis=1)
rr_sums=npsum(rr_trans, axis=1)
ll_sums=npsum(ll_trans,axis=1)
ll_sum=npsum(ll_trans)
rr_sum=npsum(cc_trans)
cc_sum=npsum(rr_trans)
emp_init_11=npsum(emp_transition_11,axis=1)
emp_init_12=npsum(emp_transition_12,axis=1)
emp_init_22=npsum(emp_transition_22,axis=1)
print "init 11"
for n,b in enumerate(bins):
    pval=binom_test(ll_sums[n], ll_sum, i11[0,n])
    print b,":", i11[0,n], emp_init_11[n],"=", pval
print "init 12"
for n,b in enumerate(bins):
    pval=binom_test(cc_sums[n], cc_sum, i12[0,n])
    print b,":",i12[0,n], emp_init_12[n],"=", pval
print "init 22"
for n,b in enumerate(bins):
    pval=binom_test(rr_sums[n], rr_sum, i22[0,n])
    print b,":",i22[0,n], emp_init_22[n],"=", pval

def str_round(number):
    if isnan(number):
        return "nan"
    return str(float(int(number*100000))/100000)
print "transition 11"
for i,b in enumerate(bins):
    strToWrite=""
    for j in range(t11.getWidth()):
        strToWrite+=str_round(t11[i,j])+" "
    print strToWrite +"\n"+" ".join(map(str_round,emp_transition_11[i,:]/sum(emp_transition_11[i,:])))
    print "-"
print "transition 12"
for i,b in enumerate(bins):
    strToWrite=""
    for j in range(t12.getWidth()):
        strToWrite+=str_round(t12[i,j])+" "
    print strToWrite +"\n"+" ".join(map(str_round,emp_transition_12[i,:]/sum(emp_transition_12[i,:])))
    print "-"
print "transition 22"
for i,b in enumerate(bins):
    strToWrite=""
    for j in range(t22.getWidth()):
        strToWrite+=str_round(t22[i,j])+" "
    print strToWrite +"\n"+" ".join(map(str_round,emp_transition_22[i,:]/sum(emp_transition_22[i,:])))
    print "-"
    
print "emission 11"
for i,b in enumerate(bins):
    print e11[i,1],emp11[i],"=",pval_e_11[i]
print "emission 12"
for i,b in enumerate(bins):
    print e12[i,1],emp12[i],"=",pval_e_12[i]
print "emission 22"
for i,b in enumerate(bins):
    print e22[i,1],emp22[i],"=",pval_e_22[i]
        
    


